// Copyright (c) 2021 Lachlan McDonald
// This work is licensed under the MIT License (MIT)
// https://github.com/lachlanmcdonald/magicavoxel-shaders
//
// xs grass_fit [Direction] [Mode] [Density] [Height] [Seed]
//
// xs_begin
// author : '@lachlanmcdonald'
// arg : { name = 'Direction'  var = 'm_direction'  range = '0 1'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Mode'  var = 'm_mode'  range = '0 4'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Density'  var = 'm_density'  range = '1 256'  value = '2'  step = '1'  precision = '0' }
// arg : { name = 'Height'  var = 'm_strand_height'  range = '1 256'  value = '10'  step = '1'  precision = '0' }
// arg : { name = 'Seed'  var = 'm_seed'  range = '1 100'  value = '1'  step = '1'  precision = '0' }
// xs_end

// Copyright (c) 2021 Lachlan McDonald
// This work is licensed under the MIT License (MIT)
// https://github.com/lachlanmcdonald/magicavoxel-shaders
//
// xs brush/grass [Direction] [Mode] [Density] [Growth] [Follow Surface] [Seed]
//
// xs_begin
// author : '@lachlanmcdonald'
// arg : { name = 'Direction'  var = 'm_direction'  range = '0 1'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Mode'  var = 'm_mode'  range = '0 4'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Density'  var = 'm_density'  range = '1 256'  value = '2'  step = '1'  precision = '0' }
// arg : { name = 'Height'  var = 'm_strand_height'  range = '0 128'  value = '10'  step = '1'  precision = '0' }
// arg : { name = 'Seed'  var = 'm_seed'  range = '1 100'  value = '1'  step = '1'  precision = '0' }
// xs_end

int direction = int(m_direction);
int mode = int(m_mode);
float density = m_density;
float global_seed = mix(-43758.6980280632, 43758.6980280632, m_seed + i_iter / 100.0);

float random(vec2 co, float seed) {
	return fract(cos(dot(co.xy, vec2(23.14069266477926, pow(sqrt(2.0), 2.0)))) * (43758.6980280632 + global_seed + seed));
}

float random(vec2 co) {
	return random(co, 0.0);
}

float pal(float p) {
	float f = floor(mix(0.0, float(i_num_color_sels), p));
	return color_sel(f);
}

float map(vec3 v) {
	if (direction == 1) {
		v.z = i_volume_size.z - v.z;
	}

	vec3 uv = floor(v) / i_volume_size;
	vec2 cell = floor(vec2(v.xy) / density);
	vec3 local = floor(mod(v, density));
	vec2 placement = floor(vec2(random(cell.xy), random(cell.xy, 170.3170)) * density);

	float base_height = 0.0;
	bool is_gap = false;
	for (float z = 0.0; z < v.z; z += 1.0) {
		float i = floor(voxel(vec3(v.xy, z)));

		if (i == 0.0) {
			if (is_gap == false) {
				base_height = z;
				is_gap = true;
			}
		} else {
			is_gap = false;
		}
	}

	base_height /= i_volume_size.z;

	if (all(equal(local.xy, placement))) {
		float d = random(cell.yx, -170.3170);
		float h = abs(m_strand_height * d / i_volume_size.z);
		float f;

		if (uv.z >= base_height && uv.z <= h + base_height) {
			if (mode == 0) {
				f = d;
			} else if (mode == 1) {
				f = random(vec2(uv.z, h));
			} else if (mode == 2) {
				f = random(v.xy);
			} else if (mode == 3) {
				f = uv.z / d;
			} else if (mode == 4) {
				f = 1.0 - (uv.z / d);
			}

			return pal(f);
		}
	}

	return voxel(v);
}
