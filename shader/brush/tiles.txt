// MIT License (MIT)
// https://github.com/lachlanmcdonald/magicavoxel-shaders
// Copyright (c) 2021 Lachlan McDonald
//
// xs brush/tiles [Width] [Height] [Depth] [Offset X] [Offset Y] [Offset Z]
//
// xs_begin
// author : '@lachlanmcdonald'
// arg : { id = '0'  name = 'Width'  value = '2'  range = '1 256'  step = '1'  decimal = '0' }
// arg : { id = '1'  name = 'Height'  value = '2'  range = '1 256'  step = '1'  decimal = '0' }
// arg : { id = '2'  name = 'Depth'  value = '2'  range = '1 256'  step = '1'  decimal = '0' }
// arg : { id = '3'  name = 'Offset X'  value = '0'  range = '0 256'  step = '1'  decimal = '0' }
// arg : { id = '4'  name = 'Offset Y'  value = '0'  range = '0 256'  step = '1'  decimal = '0' }
// arg : { id = '5'  name = 'Offset Z'  value = '0'  range = '0 256'  step = '1'  decimal = '0' }
// xs_end

vec3 dim = vec3(max(i_args[0], 1.0),
				  max(i_args[1], 1.0),
				  max(i_args[2], 1.0));
vec3 offset = vec3(max(i_args[3], 0.0),
				   max(i_args[4], 0.0),
				   max(i_args[5], 0.0));

float pal_mix(float p) {
	float f = floor(mix(0.0, float(i_num_color_sels), p));
	return color_sel(f);
}

float map(vec3 v) {
	if (mod(v.x + offset.x, dim.x * 2.0) < dim.x) {
		if (mod(v.y + offset.y, dim.y * 2.0) < dim.y) {
			if (mod(v.z + offset.z, dim.z * 2.0) < dim.z) {
				return pal_mix(0.0);
			} else {
				return pal_mix(1.0);
			}
		} else {
			if (mod(v.z + offset.z, dim.z * 2.0) < dim.z) {
				return pal_mix(1.0);
			} else {
				return pal_mix(0.0);
			}
		}
	} else {
		if (mod(v.y + offset.y, dim.y * 2.0) < dim.y) {
			if (mod(v.z + offset.z, dim.z * 2.0) < dim.z) {
				return pal_mix(1.0);
			} else {
				return pal_mix(0.0);
			}
		} else {
			if (mod(v.z + offset.z, dim.z * 2.0) < dim.z) {
				return pal_mix(0.0);
			} else {
				return pal_mix(1.0);
			}
		}
	}
}
