// Copyright (c) 2021 Lachlan McDonald
// This work is licensed under the MIT License (MIT)
// https://github.com/lachlanmcdonald/magicavoxel-shaders
//
// This script utilises or modifies code from other projects or documentation.
// Please see the attributions below for more information:
//
// 1. Copyright (c) 2020 ValgoBoi <https://github.com/ValgoBoi/clover-noise>
//    MIT License (MIT)
//    https://github.com/ValgoBoi/clover-noise/blob/master/LICENSE
//
// 2. Copyright (c) 2015 Michael Feldstein <https://github.com/msfeldstein/glsl-map>
//    MIT License (MIT)
//    https://github.com/msfeldstein/glsl-map/blob/master/LICENSE.md
//
// xs brush/treemap [Mode] [Direction] [Min Iterations] [Max Iterations] [Min. Size] [Bias] [Edge] [Seed]
//
// xs_begin
// author : '@lachlanmcdonald'
// arg : { id = '0'  name = 'Mode'  value = '0'  var = 'm_mode'  range = '0 2'  step = '1'  decimal = '0' }
// arg : { id = '1'  name = 'Direction'  value = '0'  var = 'm_direction'  range = '0 5'  step = '1'  decimal = '0' }
// arg : { id = '2'  name = 'Min Iterations'  value = '16'  var = 'm_min_iters'  range = '1 32'  step = '1'  decimal = '0' }
// arg : { id = '3'  name = 'Max Iterations'  value = '16'  var = 'm_max_iters'  range = '2 32'  step = '1'  decimal = '0' }
// arg : { id = '4'  name = 'Min. Size'  value = '10'  var = 'm_min_size'  range = '0 100'  step = '1'  decimal = '0' }
// arg : { id = '5'  name = 'Bias'  value = '50'  var = 'm_bias'  range = '0 100'  step = '1'  decimal = '0' }
// arg : { id = '6'  name = 'Edge'  value = '0'  var = 'm_edge'  range = '0 100'  step = '1'  decimal = '0' }
// arg : { id = '7'  name = 'Seed'  value = '1'  var = 'm_seed'  range = '1 100'  step = '1'  decimal = '0' }
// xs_end

int mode = int(m_mode);
int max_iters = int(m_max_iters);
int min_iters = int(min(m_max_iters, m_min_iters));
float min_size = clamp(m_min_size / 100.0, 0.0, 1.0);
float bias = clamp(m_bias / 100.0, 0.0, 1.0);
float edge = clamp(m_edge / 100.0, 0.0, 1.0);
float seed = clamp(m_seed / 100.0, 0.0, 1.0);

float clover_noise(vec2 p) {
    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));
}

struct Box {
    vec2 from;
    vec2 to;
    bool upper;
    int iter;
};

bool pointInBox(vec2 p, Box b) {
    return all(bvec4(greaterThanEqual(p, b.from), lessThanEqual(p, b.to)));
}

Box reshapeBox(Box k, bool horz, float f, vec2 p) {
    Box a = Box(k.from, k.to, false, k.iter + 1);
    Box b = Box(k.from, k.to, true, k.iter + 1);

    if (horz) {
        a.to.x = mix(a.from.x, a.to.x, f);
        b.from.x = mix(a.from.x, a.to.x, f);
    } else {
        a.to.y = mix(a.from.y, a.to.y, f);
        b.from.y = mix(a.from.y, a.to.y, f);
    }

    if (pointInBox(p, a)) {
        return a;
    } else {
        return b;
    }
}

float pal_mix(float cell) {
	float f = floor(mix(0.0, float(i_num_color_sels), cell));
	return color_sel(f);
}

vec2 range(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {
	return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

vec2 range(vec2 value, vec2 inMin, vec2 inMax) {
	return range(value, inMin, inMax, vec2(0.0), vec2(1.0));
}

float range(float value, float inMin, float inMax, float outMin, float outMax) {
  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

float range(float value, float inMin, float inMax) {
	return range(value, inMin, inMax, 0.0, 1.0);
}

float map(vec3 v) {
	vec3 uv = floor(v) / i_volume_size;

    Box b = Box(vec2(0.0), vec2(1.0), true, 1);
    vec2 p = vec2(seed);

	for (int iter = 0; iter < max_iters; iter++) {
		float m = clover_noise(p);

		// Min. iterations
		float chance_of_drop = range(float(iter), float(min_iters), float(max_iters));
		if (m < chance_of_drop) {
			break;
		}

        float f = mix(min_size, 1.0 - min_size, m);
		bool horz = clover_noise(vec2(f, iter)) <= bias;
        Box b2 = reshapeBox(b, horz, f, uv.xy);

		// Min. size
        if (all(greaterThanEqual(abs(b2.from - b2.to), vec2(min_size)))) {
            b = b2;
        }

        float w = pow(2.0, float(iter));
        p += vec2(b.upper ? w : 0.0, horz ? w : 0.0);
    }

	// Edge
	vec2 local = range(uv.xy, b.from, b.to);
	if (any(lessThanEqual(local, vec2(edge))) || any(greaterThanEqual(local, 1.0 - vec2(edge)))) {
		return 0.0;
	}

	if (mode == 0) {
		float k = pow(2.0, float(max_iters));
		float h1 = clover_noise(p.xy / k);
		float h2 = clover_noise(p.yx / k);
		return h1 >= uv.z ? pal_mix(h2) : 0.0;
	} else if (mode == 1) {
		float area = 1.0 - ((b.to.x - b.from.x) * (b.to.y - b.from.y) * max_iters);
		return area >= uv.z ? pal_mix(area) : 0.0;
	} else if (mode == 2) {
		float area = (b.to.x - b.from.x) * (b.to.y - b.from.y) * max_iters;
		return area >= uv.z ? pal_mix(area) : 0.0;
	}
}
