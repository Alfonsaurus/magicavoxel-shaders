
// Copyright (c) 2021 Lachlan McDonald
// This work is licensed under the MIT License (MIT)
// https://github.com/lachlanmcdonald/magicavoxel-shaders
//
// xs_begin
// author : '@lachlanmcdonald'
// arg : { id = '0'  name = 'Mode'  value = '0'  var = 'm_mode'  range = '0 2'  step = '1'  decimal = '0' }
// arg : { id = '1'  name = 'Size'  value = '20'  var = 'm_size'  range = '1 200'  step = '1'  decimal = '0' }
// arg : { id = '4'  name = 'Power'   value = '1'  var = 'm_power'  range = '0 10'  step = '0.1'  decimal = '1' }
// arg : { id = '4'  name = 'Sample Points'  value = '4'  var = 'm_sample_points'  range = '0 32'  step = '1'  decimal = '0' }
// arg : { id = '4'  name = 'Sample Distance'  value = '1'  var = 'm_sample_distance'  range = '0 100'  step = '1'  decimal = '0' }
// xs_end

int mode = int(m_mode);
float size = m_size / 10.0;
int sample_points = int(m_sample_points);
float sample_distance = m_sample_distance / 100.0;

float POINT_SPREAD = 0.1;
float PI = radians(180.0);

float hash(vec2 p) {
    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));
}

vec2 offset(vec2 p, float hash) {
    vec2 offset = vec2(sin(hash * PI * 100.0), cos(hash * PI * 100.0)) * floor(hash * 100.0 + 100.0) * 0.01 + 0.5;
    return p + offset * POINT_SPREAD * 2.0 + 0.5 - POINT_SPREAD;
}

float clover_noise_2d(vec2 p) {
    vec2 p_floor = floor(p);

    vec2 c_11 = offset(p_floor, hash(p_floor));
    vec2 c_10 = p_floor + vec2(0, -1);
    c_10 = offset(c_10, hash(c_10));
    vec2 c_12 = p_floor + vec2(0, 1);
    c_12 = offset(c_12, hash(c_12));
    vec2 c_01 = p_floor + vec2(-1, 0);
    c_01 = offset(c_01, hash(c_01));
    vec2 c_21 = p_floor + vec2(1, 0);
    c_21 = offset(c_21, hash(c_21));

    vec2 d_p_c11 = vec2(p.y - c_11.y, p.x - c_11.x);
    vec2 m_p_c11 = d_p_c11 * c_11;

    vec2 side_nx = m_p_c11 - d_p_c11 * c_01;
    vec2 side_px = m_p_c11 - d_p_c11 * c_21;

    vec2 a, c, d;

    if ((side_nx.y - side_nx.x < 0.0 && p.x < c_11.x) || (side_px.y - side_px.x > 0.0 && p.x >= c_11.x)) {
        vec2 side_py = m_p_c11 - d_p_c11 * c_12;

        if (side_py.y - side_py.x > 0.0) {
            a = c_12;
            c = c_01;
            d = vec2(-1.0, 1.0);
        } else {
            a = c_21;
            c = c_12;
            d = vec2(1.0, 1.0);
        }
    } else {
        vec2 side_ny = m_p_c11 - d_p_c11 * c_10;

        if (side_ny.y - side_ny.x > 0.0) {
            a = c_10;
            c = c_21;
            d = vec2(1.0, -1.0);
        } else {
            a = c_01;
            c = c_10;
            d = vec2(-1.0, -1.0);
        }
    }

    d = offset(p_floor + d, hash(p_floor + d));

    vec2 f = a;
    vec2 g = c;
    vec2 h = d;

    vec2 ac = a - c;
    vec2 bd = c_11 - d;

    if (ac.x * ac.x + ac.y * ac.y < bd.x * bd.x + bd.y * bd.y) {
        vec2 pa = p - a;

        if (pa.x * ac.y - pa.y * ac.x > 0.0) {
            h = c_11;
        }
    } else {
        vec2 pb = p - c_11;

        if (pb.x * bd.y - pb.y * bd.x > 0.0) {
            f = c_11;
        } else {
            g = c_11;
        }
    }

    vec2 bc_v0 = g - f;
    vec2 bc_v1 = h - f;
    vec2 bc_v2 = p - f;
    float den = 1.0 / (bc_v0.x * bc_v1.y - bc_v1.x * bc_v0.y);
    float v = (bc_v2.x * bc_v1.y - bc_v1.x * bc_v2.y) * den;
    float w = (bc_v0.x * bc_v2.y - bc_v2.x * bc_v0.y) * den;
    float u = 1.0 - v - w;

    v = v * v * v;
    w = w * w * w;
    u = u * u * u;
    float s = 1.0 / (u + v + w);
    v *= s;
    w *= s;
    u *= s;

    float fv = hash(f);
    float gv = hash(g);
    float hv = hash(h);

    return u * fv + v * gv + w * hv;
}

float pal(float i) {
	float f = floor(mix(0.0, float(i_num_color_sels), i));
	return color_sel(f);
}

vec2 pointOnCircle(float r, float a) {
	return vec2(r * cos(a), r * sin(a));
}

float map(vec3 v) {
	vec3 uv = floor(v) / i_volume_size;

	float p = clover_noise_2d(uv.xy * size);

	if (sample_points > 0) {
		for (int i = 0; i < sample_points; i += 1) {
			float a = 1.0 / float(sample_points) * float(i);
			vec2 k = pointOnCircle(mix(sample_distance * 0.5, sample_distance, a), a);
			p += clover_noise_2d((uv.xy + k) * size);
		}

		p /= float(sample_points) + 1.0;
	}

	p = pow(p, m_power);

	return p >= uv.z ? pal(p) : 0.0;
}
