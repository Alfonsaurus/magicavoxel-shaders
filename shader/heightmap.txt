// Copyright (c) 2021 Lachlan McDonald
// This work is licensed under the MIT License (MIT)
// https://github.com/lachlanmcdonald/magicavoxel-shaders
//
// xs_begin
// author : '@lachlanmcdonald'
// arg : { name = 'Mode'  value = '0'  var = 'm_mode'  range = '0 1'  step = '1'  decimal = '0' }
// arg : { name = 'Auto Balance'  value = '1'  var = 'm_auto'  range = '0 1'  step = '1'  decimal = '0' }
// xs_end

int mode = int(m_mode);
int auto_balance = int(m_auto);

float luminance(vec3 c) {
	return dot(c, vec3(0.2125, 0.7154, 0.0721));
}

struct Result {
	float lower;
	float upper;
}

float luminance_range() {
	ivec2 dim = ivec2(i_volume_size.xy);
	Result t = Result(1.0, 0.0);

	for (int x = 0; x < dim.x; x++) {
		for (int y = 0; y < dim.y; y++) {
			float i = voxel(vec3(float(x), float(y), 0.0));
			float l = luminance(palette(i).rgb);
			t.lower = min(t.lower, l);
			t.upper = max(t.lower, l);
		}
	}

	return t;
}

float index_range() {
	ivec2 dim = ivec2(i_volume_size.xy);
	Result t = Result(255.0, 0.0);

	for (int x = 0; x < dim.x; x++) {
		for (int y = 0; y < dim.y; y++) {
			float i = voxel(vec3(float(x), float(y), 0.0));
			t.lower = min(t.lower, i);
			t.upper = max(t.lower, i);
		}
	}

	return t;
}

float range(float value, float inMin, float inMax, float outMin, float outMax) {
	return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

float map(vec3 v) {
	vec3 uv = floor(v) / i_volume_size;
	float i = voxel(vec3(v.xy, 0.5));
	
	if (mode == 0) {
		float l = luminance(palette(i).rgb);

		if (auto_balance == 1) {
			float min_l = min_luminance();
			float max_l = max_luminance();
			l = range(l, min_l, max_l, 0.0, 1.0);
		}
	} else if (mode == 1) {
		float l = i / 255.0;

		if (auto_balance == 1) {
			float min_i = min_index();
			float max_i = max_index();
			l = range(l, min_i, max_i, 0.0, 1.0);
		}
	}
	
	return l > uv.z ? i : 0.0;
}
